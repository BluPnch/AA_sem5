\chapter{Аналитическая часть}

\textbf{Расстояние Левенштейна и Дамерау-Левенштейна}

Расстояние Левенштейна представляет собой минимальное количество односимвольных операций (вставки, удаления, замены), необходимых для преобразования одной строки в другую. В то же время расстояние Дамерау-Левенштейна также учитывает операцию транспозиции двух соседних символов, что делает его более гибким в определенных сценариях.

\textbf{Штрафы операций}
Для вычисления расстояний между строками используются следующие операции:

\begin{itemize}
    \item \textbf{Вставка (I)} — добавление символа в строку. Штраф операции — 1.
    \item \textbf{Удаление (D)} — удаление символа из строки. Штраф операции — 1.
    \item \textbf{Замена (R)} — замена одного символа на другой. Штраф операции — 1 (если символы разные, если одинаковые — 0).
    \item \textbf{Транспозиция (T)} — перестановка двух соседних символов (только для расстояния Дамерау-Левенштейна). Штраф операции — 1.
\end{itemize}

Стоимость каждой операции фиксирована и равна 1, что упрощает вычисления.

\section{Итеративный алгоритм Левенштейна}

Итеративный алгоритм использует матрицу для хранения промежуточных значений. Это обеспечивает линейную сложность по времени.

Пусть \( s_1 \) и \( s_2 \) — две строки длиной \( M \) и \( N \) соответственно над некоторым алфавитом. Тогда расстояние Левенштейна \( d(s_1, s_2) \) можно вычислить по следующей рекуррентной формуле:

\begin{equation}
d(s_1, s_2) = D(M, N),
\end{equation}
где

\begin{equation}
D(i, j) =
\begin{cases}
0, & \text{если } i = 0 \text{ и } j = 0, \\
i, & \text{если } j = 0 \text{ и } i > 0, \\
j, & \text{если } i = 0 \text{ и } j > 0, \\
\min \left( 
  D(i, j - 1) + 1, \right. \\
  \quad D(i - 1, j) + 1, & \text{если } i > 0 \text{ и } j > 0, \\
  \quad D(i - 1, j - 1) + m(S_1[i], S_2[j])
  \left. \right)
\end{cases}
\end{equation}
где \( m(a, b) = 0 \), если \( a = b \), и \( 1 \) в противном случае. Функция \( \min\{a, b, c\} \) возвращает наименьшее из значений.


\vspace{0.5cm}
\textbf{Шаги алгоритма}:
\begin{enumerate}
    \item Инициализировать матрицу $D$ размером $(m+1) \times (n+1)$, где $m$ — длина строки $s1$, $n$ — длина строки $s2$. Строка $s1$ преобразуется в строку $s2$.
    \item Заполнить первую строку и первый столбец значениями от 0 до $m$ и $n$ соответственно. Эти значения соответствуют стоимости преобразования пустой строки в строку с длиной $m$ или $n$.
    \item Вычислять стоимость операций для каждой пары символов $s1[i]$ и $s2[j]$:
    \begin{equation}
    D[i][j] = \min \left\{
    \begin{array}{l}
        D[i-1][j] + 1 \quad  \text{(удаление)} \\
        D[i][j-1] + 1 \quad  \text{(вставка)} \\
        D[i-1][j-1] + m(s1[i], s2[j]) \quad  \text{(замена/совпадение)}
    \end{array}
    \right.
	\end{equation}


    \item Значение в $D[m][n]$ будет равно расстоянию Левенштейна между строками.
\end{enumerate}

\textbf{Пример}:
Для строк $s1 = \texttt{КОТ}$ и $s2 = \texttt{СКАТ}$, матрица будет выглядеть следующим образом:

\begin{equation}
\begin{array}{c|cccccccc}
  &   & C & K & A & T \\
\hline
  & 0 & 1 & 2 & 3 & 4 \\
K & 1 & 1 & 1 & 2 & 3 \\
O & 2 & 2 & 2 & 2 & 3 \\
T & 3 & 3 & 3 & 3 & 2 \\
\end{array}
\end{equation}



\section{Рекурсивный алгоритм Левенштейна}

Рекурсивный алгоритм основан на вычислении каждой возможной операции (вставки, удаления или замены) для каждого символа обеих строк. Поскольку на каждом шаге происходит ветвление вызовов для каждой операции, это приводит к значительному увеличению вычислительной сложности.

\vspace{0.5cm}
\textbf{Шаги алгоритма}:
\begin{enumerate}
    \item Если одна из строк пустая, вернуть длину другой строки (стоимость всех операций вставки/удаления).
    \item Для каждой пары символов $s1[i]$ и $s2[j]$, рекурсивно вычислить минимальную стоимость преобразования с помощью следующих операций:
    \begin{itemize}
        \item вставка,
        \item удаление,
        \item замена (если символы разные).
    \end{itemize}
    \item Возвращаем минимальную стоимость из трех вариантов.
\end{enumerate}

\section{Рекурсивный алгоритм с мемоизацией}

Рекурсивный алгоритм с мемоизацией устраняет недостатки предыдущего подхода, сохраняя результаты вычислений. Это позволяет избежать повторных вызовов.

\vspace{0.5cm}
\textbf{Шаги алгоритма}:
\begin{enumerate}
    \item Инициализировать таблицу $memo$ размерами $(m+1) \times (n+1)$, заполненную значениями $-1$.
    \item Проверять таблицу на наличие заранее вычисленных значений для каждого вызова функции.
    \item Если значение еще не вычислено, рекурсивно вычислить его и сохранить в таблице.
\end{enumerate}


\section{Алгоритм Дамерау-Левенштейна}

Алгоритм Дамерау-Левенштейна использует ту же схему, что и Левенштейн, с добавлением проверки на транспозицию двух соседних символов. Это делает его полезным в задачах, где возможны перестановки символов.

\vspace{0.5cm}
\textbf{Шаги алгоритма}:
\begin{enumerate}
    \item Инициализировать матрицу $D$ размером $(m+1) \times (n+1)$.
    \item Выполнять все операции для расстояния Левенштейна.
    \item Если символы $s1[i-1]$ и $s1[i-2]$ равны $s2[j-2]$ и $s2[j-1]$, добавить проверку транспозиции:
    \begin{equation}
        D[i][j] = \min(D[i][j], D[i-2][j-2] + 1)
    \end{equation}
\end{enumerate}



\section*{Вывод}

В аналитической части были разобраны теоретические основы алгоритмов Левенштейна и Дамерау-Левенштейна. Описаны основные операции, их стоимость.
